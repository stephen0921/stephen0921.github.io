<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Yao He's Awesome Site</title><link>https://stephen0921.github.io/</link><description>Some tips and notes need to write here.</description><atom:link href="https://stephen0921.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2017 &lt;a href="mailto:stephen0921@gmail.com"&gt;Yao He&lt;/a&gt; </copyright><lastBuildDate>Wed, 06 Dec 2017 15:18:47 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Tmux introduction</title><link>https://stephen0921.github.io/posts/2017-12-06-tmux-part1/</link><dc:creator>Yao He</dc:creator><description>&lt;p&gt;
什么是Tmux？
&lt;/p&gt;

&lt;p&gt;
Tmux可以理解为是一个terminal控制器，是对我们的terminal的扩展，同时我们可以利用它来建立自己的一套workflow。
先上一张图，感受一下。
&lt;/p&gt;

&lt;img src="https://stephen0921.github.io/images/tmux.png" class="img-thumbnail" width="80%"&gt;</description><guid>https://stephen0921.github.io/posts/2017-12-06-tmux-part1/</guid><pubDate>Wed, 06 Dec 2017 14:35:32 GMT</pubDate></item><item><title>Emacs column edit</title><link>https://stephen0921.github.io/posts/2017-10-31-emacs-rectangle/</link><dc:creator>Yao He</dc:creator><description>&lt;p&gt;
以前一直觉得emacs的列操作不如vim好用，经过最近一段时间的深入使用，让我的看法有所改变。比如下面的代码我想多加4组agent，那么怎么做呢？
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;agent0 u_agent_0(.clk1(clk),.rst1(rst));
agent1 u_agent_1(.clk1(clk),.rst1(rst));
agent2 u_agent_2(.clk1(clk),.rst1(rst));
agent3 u_agent_3(.clk1(clk),.rst1(rst));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
先copy四行出来。
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;agent0 u_agent_0(.clk1(clk),.rst1(rst));
agent1 u_agent_1(.clk1(clk),.rst1(rst));
agent2 u_agent_2(.clk1(clk),.rst1(rst));
agent3 u_agent_3(.clk1(clk),.rst1(rst));

// the 4 lines below are copied from above
agent0 u_agent_0(.clk1(clk),.rst1(rst));
agent1 u_agent_1(.clk1(clk),.rst1(rst));
agent2 u_agent_2(.clk1(clk),.rst1(rst));
agent3 u_agent_3(.clk1(clk),.rst1(rst));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
然后，先选中要修改的4行，然后M-C-%(或者M-x，键入query-replace-regexp, 回车)，在mini-buffer中输入被替换的表达式是
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;-9&lt;span class="o"&gt;]&lt;/span&gt;+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
目标表达式是 
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="se"&gt;\,&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;+ &lt;span class="m"&gt;4&lt;/span&gt; &lt;span class="se"&gt;\#&lt;/span&gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
然后回车，就有一个交互式提示，想要替换掉的，按y，不想替换的按n，如果想全部替换的话，按！,具体命令可以按？来查询。
如图所示。
&lt;/p&gt;

&lt;img src="https://stephen0921.github.io/images/emacs.PNG" class="img-thumbnail" width="60%"&gt;          

&lt;p&gt;
经过4轮的"yynn"后就得到了下面的代码。
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;agent0 u_agent_0(.clk1(clk),.rst1(rst));
agent1 u_agent_1(.clk1(clk),.rst1(rst));
agent2 u_agent_2(.clk1(clk),.rst1(rst));
agent3 u_agent_3(.clk1(clk),.rst1(rst));

// the 4 lines below are copied from above, then replace
agent4 u_agent_4(.clk1(clk),.rst1(rst));
agent5 u_agent_5(.clk1(clk),.rst1(rst));
agent6 u_agent_6(.clk1(clk),.rst1(rst));
agent7 u_agent_7(.clk1(clk),.rst1(rst));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
这个过程略显复杂，如果是emacs版本25.2的话，就可以使用(rectangle-mark-mode)来单独选中要改变的列，然后整体替换就ok了。
如下图所示。
&lt;/p&gt;
&lt;img src="https://stephen0921.github.io/images/emacs-rect.PNG" class="img-thumbnail" width="60%"&gt;
&lt;img src="https://stephen0921.github.io/images/emacs-rect-2.PNG" class="img-thumbnail" width="60%"&gt;</description><guid>https://stephen0921.github.io/posts/2017-10-31-emacs-rectangle/</guid><pubDate>Tue, 31 Oct 2017 10:35:32 GMT</pubDate></item><item><title>Use Openxmlformat to Generate WORD DOC</title><link>https://stephen0921.github.io/posts/2017-09-22-openxmlformat/</link><dc:creator>Yao He</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Generating MS-WORD doc using openxmlformat&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
使用openxmlformat格式来描述，可以用WORD打开的xml文档。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://stephen0921.github.io/posts/2017-09-22-openxmlformat/</guid><pubDate>Fri, 22 Sep 2017 03:55:32 GMT</pubDate></item><item><title>Generate Tags for Emacs by Verdi</title><link>https://stephen0921.github.io/posts/2017-09-12-emacs-tags-verdi/</link><dc:creator>Yao He</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Generate Tags for Emacs by Verdi&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
无意中看到SNUG的一个文章，作者通过使用Verdi来生成Emacs以及Vim的tags文件，很棒。我一直没有找到特别好的办法来用Emacs浏览verilog 代码工程，之前也是使用Emacs的插件projectile来grep关键字。我赶紧按照作者的描述操作起来了。
&lt;/p&gt;

&lt;img src="https://stephen0921.github.io/images/tags.png" class="img-thumbnail" width="60%"&gt;

&lt;p&gt;
作者的tcl脚本是放在&lt;a href="https://www.vc-apps.org/sitepages/downloadList.aspx"&gt;这里的&lt;/a&gt; ，居然排在第一个。
&lt;/p&gt;

&lt;img src="https://stephen0921.github.io/images/vcc.PNG" class="img-thumbnail" width="60%"&gt;

&lt;p&gt;
在Verdi打开tcl命令窗口，然后source下载的tcl脚本。
&lt;/p&gt;

&lt;img src="https://stephen0921.github.io/images/verdi.PNG" class="img-thumbnail" width="60%"&gt;

&lt;p&gt;
生成的vim版本的tags文件是ok的，能用。Emacs版本的TAGS文件居然不能跳转！
&lt;/p&gt;

&lt;p&gt;
仔细查了一遍，应该是作者把emacs tags文件的格式弄错了，看来作者一定是vim用户了，或者我使用的emacs版本（25.2）太高了？
&lt;/p&gt;

&lt;p&gt;
再看了一遍论文，作者文字描述的格式和他实际脚本生成的TAGS格式不一致，把tag_definition_text丢掉了，所以跳转有问题。
&lt;/p&gt;

&lt;img src="https://stephen0921.github.io/images/emacs_tags_format.png" class="img-thumbnail" width="60%"&gt;

&lt;p&gt;
去&lt;a href="https://www.vc-apps.org/sitepages/gettingstarted.aspx"&gt;官网&lt;/a&gt;查到了npi参考手册，fix一下tcl代码。
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;foreach&lt;/span&gt; &lt;span class="k"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;index&lt;/span&gt; tagInfo&lt;span class="k"&gt;}&lt;/span&gt; &lt;span class="nv"&gt;$sorted_ident&lt;/span&gt; &lt;span class="k"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;set&lt;/span&gt; srcFile &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;lindex&lt;/span&gt; &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;split&lt;/span&gt; &lt;span class="nv"&gt;$tagInfo&lt;/span&gt;&lt;span class="k"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="k"&gt;]&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;$fileName&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nv"&gt;$srcFile&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt; &lt;span class="k"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;set&lt;/span&gt; tag &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;lindex&lt;/span&gt; &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;split&lt;/span&gt; &lt;span class="nv"&gt;$tagInfo&lt;/span&gt;&lt;span class="k"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="k"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;set&lt;/span&gt; line &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;lindex&lt;/span&gt; &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;split&lt;/span&gt; &lt;span class="nv"&gt;$tagInfo&lt;/span&gt;&lt;span class="k"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="k"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;set&lt;/span&gt; offset &lt;span class="nv"&gt;$byteCounts&lt;/span&gt;&lt;span class="k"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$line&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

    &lt;span class="c"&gt;#======= fix by yaohe begin ===========#&lt;/span&gt;
      &lt;span class="c"&gt;#set entry "\x7f$tag\x01,$offset"&lt;/span&gt;
      &lt;span class="k"&gt;set&lt;/span&gt; file_hdl &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;npi_text_file_by_name&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;name &lt;span class="s2"&gt;"$srcFile"&lt;/span&gt;&lt;span class="k"&gt;]&lt;/span&gt;
      &lt;span class="k"&gt;set&lt;/span&gt; line_hdl &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;npi_text_line_by_number&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;ref &lt;span class="nv"&gt;$file_hdl&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;number &lt;span class="nv"&gt;$line&lt;/span&gt;&lt;span class="k"&gt;]&lt;/span&gt;
      &lt;span class="k"&gt;set&lt;/span&gt; line_content &lt;span class="k"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;npi_text_property_str&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;type npiTextLineContent &lt;span class="o"&gt;-&lt;/span&gt;ref &lt;span class="nv"&gt;$line_hdl&lt;/span&gt;&lt;span class="k"&gt;]&lt;/span&gt;
      &lt;span class="nb"&gt;regsub&lt;/span&gt; &lt;span class="k"&gt;{&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt; &lt;span class="nv"&gt;$line_content&lt;/span&gt; &lt;span class="k"&gt;{}&lt;/span&gt; line_content
      &lt;span class="k"&gt;set&lt;/span&gt; entry &lt;span class="s2"&gt;"$line_content\x7f$line,$offset"&lt;/span&gt;
    &lt;span class="c"&gt;#======= fix by yaohe end ===========#&lt;/span&gt;

    &lt;span class="nb"&gt;append&lt;/span&gt; entryList &lt;span class="s2"&gt;"\n"&lt;/span&gt; &lt;span class="nv"&gt;$entry&lt;/span&gt;
  &lt;span class="k"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
终于好用了。
&lt;/p&gt;

&lt;img src="https://stephen0921.github.io/images/emacs_tags_ok.png" class="img-thumbnail" width="60%"&gt;

&lt;p&gt;
新的tcl代码我备份我的&lt;a href="https://github.com/stephen0921/GenEmacsTagsByVerdi"&gt;github&lt;/a&gt;上，因为实在联系不上作者。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://stephen0921.github.io/posts/2017-09-12-emacs-tags-verdi/</guid><pubDate>Tue, 12 Sep 2017 02:35:32 GMT</pubDate></item><item><title>UVM Example Reference 1</title><link>https://stephen0921.github.io/posts/2017-09-11-uvm-ref-flow1/</link><dc:creator>Yao He</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;UVM Example Reference 1&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
uvm_ref_flow_1.2是不错的学习材料，从UT到SOC的环境都可以参考这里面的代码来写，至少可以当做代码的模板来用。
&lt;/p&gt;

&lt;p&gt;
和我之前一般看到的做法不同，monitor被完全实现在了transaction level，signal level的东西放在了一个叫collector的class里面。
&lt;/p&gt;

&lt;p&gt;
还有一个特别值得说明是，在apb_slave_seq_lib.sv中的simple_response_seq通过其p_sequencer的tlm接口addr_trans_port来生成包，不错的应用方法。
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;class simple_response_seq extends uvm_sequence #(apb_transfer);
   // ...
   virtual task body();
      `uvm_info(get_type_name(), "Starting...", UVM_MEDIUM)
      forever begin
	 p_sequencer.addr_trans_port.peek(util_transfer);
	 // ...
      end
   endtask : body
endclass : simple_response_seq
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
为了让sequencer能看到发包的情况，建立了一条tlm通道。从总线到apb_collector，再到apb_monitor，最后到apb_slave_sequencer。
&lt;/p&gt;
&lt;img src="https://stephen0921.github.io/images/uvm_ref_flow1.png" class="img-thumbnail" width="60%"&gt;


&lt;p&gt;
用事件来在同一个class的两个task之间做同步和信息传递，用peek的tlm通路来层层传递。
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;class apb_slave_sequencer extends uvm_sequencer #(apb_transfer);
   // ...
   uvm_blocking_peek_port#(apb_transfer) addr_trans_port;
   // ...
endclass : apb_slave_sequencer

class apb_monitor extends uvm_monitor;
   // ...
   // Allows the sequencer to look at monitored data for responses
  uvm_blocking_peek_imp#(apb_transfer,apb_monitor) addr_trans_export;

  // Allows monitor to look at collector for address information
  uvm_blocking_peek_port#(apb_transfer) addr_trans_port;

  event trans_addr_grabbed;
endclass : apb_monitor

  // UVM run_phase
task apb_monitor::run_phase(uvm_phase phase);
  forever begin
    addr_trans_port.peek(trans_collected);
    `uvm_info(get_type_name(), $sformatf("Address Phase Complete: %h[%s]", trans_collected.addr, trans_collected.direction.name() ), UVM_HIGH)
    -&amp;gt; trans_addr_grabbed;
  end
endtask : run_phase

// FUNCTION: peek - Allows the sequencer to peek at monitor for responses
task apb_monitor::peek(output apb_transfer trans);
  @trans_addr_grabbed;
  trans = trans_collected;
endtask : peek

class apb_collector extends uvm_component;
   // ...
   // TLM Port - Allows sequencer access to transfer during address phase
  uvm_blocking_peek_imp#(apb_transfer,apb_collector) addr_trans_export;
  event addr_trans_grabbed;
endclass : apb_collector

   // UVM run_phase()
task apb_collector::run_phase(uvm_phase phase);
    @(posedge vif.preset);
    `uvm_info(get_type_name(), "Detected Reset Done", UVM_LOW)
    collect_transactions();
endtask : run_phase

// collect_transactions
task apb_collector::collect_transactions();
  forever begin
    @(posedge vif.pclock iff (vif.psel != 0));
    void'(this.begin_tr(trans_collected,"APB_COLLECTOR","UVM Debug","APB collector transaction inside collect_transactions()"));
    trans_collected.addr = vif.paddr;
    trans_collected.master = cfg.master_config.name;
    trans_collected.slave = cfg.get_slave_name_by_addr(trans_collected.addr);
    case (vif.prwd)
      1'b0 : trans_collected.direction = APB_READ;
      1'b1 : trans_collected.direction = APB_WRITE;
    endcase
      @(posedge vif.pclock);
    if(trans_collected.direction == APB_READ)
      trans_collected.data = vif.prdata;
    if (trans_collected.direction == APB_WRITE)
      trans_collected.data = vif.pwdata;
    -&amp;gt; addr_trans_grabbed;
    @(posedge vif.pclock);
    if(trans_collected.direction == APB_READ) begin
	if(vif.pready != 1'b1)
	  @(posedge vif.pclock);
      trans_collected.data = vif.prdata;
      end
    this.end_tr(trans_collected);
    item_collected_port.write(trans_collected);
    `uvm_info(get_type_name(), $sformatf("Transfer collected :\n%s",
	      trans_collected.sprint()), UVM_MEDIUM)
      `ifdef HEAP
      runq.push_back(trans_collected);
      `endif
     num_transactions++;
    end
endtask : collect_transactions

task apb_collector::peek(output apb_transfer trans);
  @addr_trans_grabbed;
  trans = trans_collected;
endtask : peek
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
再看一下连接关系。
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// UVM connect_phase
function void apb_env::connect_phase(uvm_phase phase);
  super.connect_phase(phase);
  // Get the virtual interface if set via get_config
  if (!uvm_config_db#(virtual apb_if)::get(this, "", "vif", vif))
    `uvm_error("NOVIF",{"virtual interface must be set for: ",get_full_name(),".vif"})
  bus_collector.item_collected_port.connect(bus_monitor.coll_mon_port);
  bus_monitor.addr_trans_port.connect(bus_collector.addr_trans_export);
  master.monitor = bus_monitor;
  master.collector = bus_collector;
  foreach(slaves[i]) begin
    slaves[i].monitor = bus_monitor;
    slaves[i].collector = bus_collector;
    if (slaves[i].is_active == UVM_ACTIVE)
      slaves[i].sequencer.addr_trans_port.connect(bus_monitor.addr_trans_export);
  end
endfunction : connect_phase
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://stephen0921.github.io/posts/2017-09-11-uvm-ref-flow1/</guid><pubDate>Mon, 11 Sep 2017 07:05:32 GMT</pubDate></item><item><title>Emacs verilog mode</title><link>https://stephen0921.github.io/posts/2017-08-30-emacs-verilog/</link><dc:creator>Yao He</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Emacs的verilog mode&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
是不是觉得verilog的语法，有一些啰嗦呢，实例的例化、信号连接工作太无聊呢？来来来，试试Emacs。
有人说Emacs老土的编辑器了，现在没有人用了吧，还真不是，其强大的扩展性（可折腾性），真是IC验证人的出门在外必备良药啊。
那么在哪里能安装呢？&lt;a href="https://www.gnu.org/software/emacs/download.html"&gt;来这里找&lt;/a&gt; 。
&lt;/p&gt;

&lt;p&gt;
如果是windows版本，需要设置一下环境变量。方法是，控制面板-&amp;gt;系统-&amp;gt;高级系统设置-&amp;gt;环境变量-&amp;gt;新建-&amp;gt;变量名是HOME-&amp;gt;变量值是C:\Users\heyao\documents。
&lt;/p&gt;

&lt;p&gt;
根据自己的需要选择合适的变量值，用来存放用户的.emacs.d文件夹以及.emacs文件，我选择的是C:\Users\heyao\documents。.emacs.d主要是用来放置一下emacs的插件，.emacs是用户自己的初始化设置。
&lt;/p&gt;

&lt;p&gt;
先不折腾这个配置，打开emacs，敲入下面代码:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;module fanout (/*AUTOARG*/)
   input i;
   output [31:0] o;
   wire [31:0] o = {32{i}};
endmodule
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
保存，（快捷键CTRL+x CTRL+s，为了便于说明，用C-x C-s来表示），命名文件为fanout.v。
&lt;/p&gt;

&lt;p&gt;
然后，用户C-c C-a，代码就变成了如下:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;module fanout (/*AUTOARG*/
   // Outputs
   o,
   // Inputs
   i
   )
   input i;
   output [31:0] o;
   wire [31:0] o = {32{i}};
endmodule
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
我们再C-x 3，并排打开窗口，然后C-x C-f，新建一个文件ex_inst.v，如下:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;module ex_inst (/*AUTOARG*/)
   input i;
   output [31:0] o;
   inout      io;

   fanout fanout (/*AUTOINST*/);
endmodule
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
然后，C-c C-a，代码就变成了如下:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;module ex_inst (/*AUTOARG*/
   // Outputs
   o,
   // Inouts
   io,
   // Inputs
   i
   )
   input i;
   output [31:0] o;
   inout      io;

   fanout fanout (/*AUTOINST*/
	  // Outputs
	  .o            (o[31:0]),
	  // Inputs
	  .i            (i));
endmodule
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
可以看到Emacs自动帮忙做了实例化。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://stephen0921.github.io/posts/2017-08-30-emacs-verilog/</guid><pubDate>Wed, 30 Aug 2017 09:25:32 GMT</pubDate></item><item><title>IEEE Floating Point Number</title><link>https://stephen0921.github.io/posts/2017-08-15-ieee-floating/</link><dc:creator>Yao He</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;IEEE Standard 754&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
关于浮点数的标准，这个讲得很清晰，尤其是关于denormalized。
&lt;/p&gt;

&lt;p&gt;
&lt;a href="http://steve.hollasch.net/cgindex/coding/ieeefloat.html"&gt;ieeefloat&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://stephen0921.github.io/posts/2017-08-15-ieee-floating/</guid><pubDate>Tue, 15 Aug 2017 08:33:53 GMT</pubDate></item><item><title>Learn some SQL</title><link>https://stephen0921.github.io/posts/2017-08-11-sqlite/</link><dc:creator>Yao He</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;Learn some SQL&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
  SQL(structured query language)可以理解为一种标准语言，不管底层最终的database是MySQL还是sqlite，都是支持这个标准语言的。虽然在脚本语言中，有DBI(database interface) module，比如Perl里的DBIx::Class，为用户操作数据库提供了便利的wrapper，但是了解一些基本的SQL操作，很有必要。
推荐两个非常棒的SQL教学视频，比如:&lt;a href="https://www.youtube.com/watch?v=QjICgmk31js&amp;amp;list=PLGLfVvz_LVvTsslWD1HBQEjBbmAaAF9Xy&amp;amp;index=1"&gt;sqlite3 tutorial&lt;/a&gt; 和 &lt;a href="https://www.youtube.com/watch?v=yPu6qV5byu4&amp;amp;list=PLSBBbFozymr309Vzn5cmG2kxGKV6pHnKP&amp;amp;index=5"&gt;MySQL&lt;/a&gt; 。
&lt;/p&gt;

&lt;p&gt;
再回到我最近看的MojoExample源代码上来。Schema::Result::Blog.pm，有一段代码是这样:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nn"&gt;__PACKAGE__&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;has_many&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="s"&gt;"blog_tags"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s"&gt;"Schema::Result::BlogTag"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;"foreign.blog"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"self.id"&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;cascade_copy&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cascade_delete&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
就是说一个Blog有多个BlogTag，table blog_tags的column成员blog映射到table blogs的column成员id上。
再来看Schema::Result::BlogTag.pm的一段:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nn"&gt;__PACKAGE__&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;belongs_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="s"&gt;"blog"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s"&gt;"Schema::Result::Blog"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"blog"&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;is_deferrable&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;on_delete&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"CASCADE"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;on_update&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"CASCADE"&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
这个代码不够友好，参考这个帖子&lt;a href="http://blog.johngoulah.com/2009/05/versioning-with-dbic/"&gt;versioning-with-dbic&lt;/a&gt; 后，我们把这一段改一下:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nn"&gt;__PACKAGE__&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;belongs_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="s"&gt;"blog"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="s"&gt;"Schema::Result::Blog"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;"foreign.id"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"self.blog"&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;is_deferrable&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;on_delete&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"CASCADE"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;on_update&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"CASCADE"&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
这样就清晰多了，table blogs的column成员id映射到table blog_tags的column成员blog上。
&lt;/p&gt;

&lt;p&gt;
进到MojoExample目录下，看一下现有的数据库长什么样:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sqlite3 test.db
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
发几个命令熟悉一下，最后一条是JOIN命令，另外还有LEFT JOIN，RIGHT JOIN等，去w3school上看吧。
&lt;/p&gt;
&lt;img src="https://stephen0921.github.io/images/sqlite3.png" class="img-thumbnail" width="60%"&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://stephen0921.github.io/posts/2017-08-11-sqlite/</guid><pubDate>Fri, 11 Aug 2017 09:19:11 GMT</pubDate></item><item><title>My, Our and Local in Perl</title><link>https://stephen0921.github.io/posts/2017-08-10-my-our/</link><dc:creator>Yao He</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;My, Our and local&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
"my"比较常见，"our"和"local"偶尔会出现。查了好多文档，比如perldoc中的perlmod说明，也是比较模糊，而且又提到"lexical"变量的说法，更是让人一头雾水。下面这个文档比较清晰，值得一读。它从Perl发展的历史角度来讲述区别，同时解释了package变量和"lexical"变量的含义。
&lt;a href="http://perl.plover.com/FAQs/Namespaces.html"&gt;Coping with Scoping&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
举一个例子，加深理解。
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;abc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;strict&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;warnings&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="nv"&gt;$VERSION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;sub&lt;/span&gt; &lt;span class="nf"&gt;get_ver&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;$VERSION&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;main&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"step 1: $abc::VERSION\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"step 2: "&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nn"&gt;abc::&lt;/span&gt;&lt;span class="n"&gt;get_ver&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
如上面代码所示，我们想在"package abc"中使用具有全局属性的package变量"$VERSION"，但是由于用了"use strict"，所以上面一段代码编译会报如下错。
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Global symbol &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$VERSION&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; requires explicit package name &lt;span class="o"&gt;(&lt;/span&gt;did you forget to &lt;span class="nb"&gt;declare&lt;/span&gt; &lt;span class="s2"&gt;"my &lt;/span&gt;&lt;span class="nv"&gt;$VERSION&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;?&lt;span class="o"&gt;)&lt;/span&gt; at a.pl line &lt;span class="m"&gt;7&lt;/span&gt;.
Global symbol &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$VERSION&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; requires explicit package name &lt;span class="o"&gt;(&lt;/span&gt;did you forget to &lt;span class="nb"&gt;declare&lt;/span&gt; &lt;span class="s2"&gt;"my &lt;/span&gt;&lt;span class="nv"&gt;$VERSION&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;?&lt;span class="o"&gt;)&lt;/span&gt; at a.pl line &lt;span class="m"&gt;10&lt;/span&gt;.
Execution of a.pl aborted due to compilation errors.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
根据提示我们可以修改成下面这样，在package abc内部使用自己的变量也要加上package名称做前缀:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;abc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;strict&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;warnings&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="nv"&gt;$&lt;/span&gt;&lt;span class="nn"&gt;abc::&lt;/span&gt;&lt;span class="nv"&gt;VERSION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;sub&lt;/span&gt; &lt;span class="nf"&gt;get_ver&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;$&lt;/span&gt;&lt;span class="nn"&gt;abc::&lt;/span&gt;&lt;span class="nv"&gt;VERSION&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;main&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"step 1: $abc::VERSION\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"step 2: "&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nn"&gt;abc::&lt;/span&gt;&lt;span class="n"&gt;get_ver&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
为了不这样麻烦，出现了our函数，这样我们就能更优雅一点的使用package变量了:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;abc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;strict&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;warnings&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;our&lt;/span&gt; &lt;span class="nv"&gt;$VERSION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;sub&lt;/span&gt; &lt;span class="nf"&gt;get_ver&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;$VERSION&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;main&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"step 1: $abc::VERSION\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"step 2: "&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nn"&gt;abc::&lt;/span&gt;&lt;span class="n"&gt;get_ver&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://stephen0921.github.io/posts/2017-08-10-my-our/</guid><pubDate>Thu, 10 Aug 2017 05:44:21 GMT</pubDate></item><item><title>Uvm Reporter Mechanism</title><link>https://stephen0921.github.io/posts/2017-08-07-uvm-reporter/</link><dc:creator>Yao He</dc:creator><description>&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;UVM Reporter Mechanism&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
UVM的log打印分为6个等级，如下图所示:
&lt;/p&gt;
&lt;img src="https://stephen0921.github.io/images/uvm_verbosity.png" class="img-thumbnail" width="60%"&gt;

&lt;p&gt;
由下至上，打印的等级逐级升高。假设在一个task里面有如下的代码，那么即将打印的是后三条。
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;`uvm_info("ID0", "this is debug message", UVM_DEBUG)
`uvm_info("ID1", "this is full message", UVM_FULL)
`uvm_info("ID2", "this is high message", UVM_HIGH)
`uvm_info("ID3", "this is medium message", UVM_MEDIUM)
`uvm_info("ID4", "this is low message", UVM_LOW)
`uvm_info("ID5", "this is none message", UVM_NONE)
&lt;/pre&gt;&lt;/div&gt;

&lt;img src="https://stephen0921.github.io/images/uvm_log.png" class="img-thumbnail" width="60%"&gt;

&lt;p&gt;
因为仿真器默认的verbosity是UVM_MEDIUM，所以ID0~ID2的信息没有打印出来。可以通过命令行来修改打印的verbosity，比如:
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;+uvm_set_verbosity&lt;span class="o"&gt;=&lt;/span&gt;component_name,id,verbosity,phase_name,optional_time
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
`uvm_warning、`uvm_error、`uvm_fatal可以看作是verbosity都是UVM_NONE的`uvm_info，所以它们是默认打印的。但是它们的行为可以通过命令行改变，比如默认的`uvm_fatal是要立刻停止仿真的，但是可以通过+uvm_set_action来改变它。
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;+uvm_set_action&lt;span class="o"&gt;=&lt;/span&gt;component,id,severity,action
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
这里可以做简单的练习:
&lt;a href="http://www.edaplayground.com/x/5xF7"&gt;my simple test&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><guid>https://stephen0921.github.io/posts/2017-08-07-uvm-reporter/</guid><pubDate>Mon, 07 Aug 2017 07:34:50 GMT</pubDate></item></channel></rss>