
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">system verilog中的面向对象</h2>
<div class="outline-text-2" id="text-1">
<p>
下面的代码中，bad_tr继承tr，所以bad_tr具有了成员变量num和good的同时，也有自己的变量bad。
</p>
<div class="highlight"><pre><span></span>class tr;
   bit num;
   bit good;

   function new();
      num = 0;
      good = 0;
   endfunction // new

endclass // tr

class bad_tr extends tr;
   bit bad;

   function new();
      super.new();
      bad = 1;
   endfunction // new

endclass // bad_tr
</pre></div>


<p>
下面的代码，在initial块中create了两个对象，分别是m_tr和m_bad_tr，并且m_tr指向了其子类对象m_bad_tr。当想做downcast时，也就是说比如让m_bad_tr1指向tr的子类时，要用$cast函数。
</p>
<div class="highlight"><pre><span></span>tr     m_tr;
bad_tr m_bad_tr;

bad_tr m_bad_tr1;

initial begin
   m_tr = new();
   m_bad_tr = new();
   m_tr = m_bad_tr;

   if ($cast(m_bad_tr1, m_tr))
     $display(&quot;Successful!&quot;);
   else
     $display(&quot;Can not assign!&quot;);

end
</pre></div>
</div>
</div>
